// Generated by CoffeeScript 1.7.1
(function() {
  var ESCAPED_CHARACTERS, Expression, LOOKUP_REGEX, Operator, PATH_REGEX, ParsedChunk, STRIP_COMMAS, abbr, category, category_id, log, matcher, operator_list, operators, operators_by_code, params, parse_expression, _, _contains, _i, _j, _len, _len1, _ref, _ref1, _replace_dict_items, _strStrip,
    __slice = [].slice;

  _ = require('underscore');

  log = function() {
    var args;
    args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
    return console.log.apply(console, args);
  };

  parse_expression = function(input) {
    if (_.isString(input)) {
      return new Expression({
        str: input
      });
    } else if (_.isArray(input)) {
      return new Expression({
        arr: input
      });
    } else {
      return new Expression(input);
    }
  };

  module.exports = parse_expression;


  /*
  begin "operators"
   */

  params = {
    "categories": ['punctuation', 'prefix', 'methods', 'spacing', 'unkown', 'parentheses', 'comparators', 'operators', 'values', 'logic'],
    "prefix": {
      matchers: [
        {
          regex: '^jr\:',
          string: 'jr:',
          repr: 'JR'
        }
      ]
    },
    "punctuation": {
      abbr: "punc",
      matchers: [["..", "DOTPREVIOUS"], [".", "DOTSELF"], ["//", 'DBLFWDSLASH'], ["/", 'FWDSLASH'], [",", 'COMMA']]
    },
    "methods": {
      abbr: "method",
      matchers: ["ceiling", "concat", "count", "count-selected", "current", "date", "false", "floor", "id", "if", "not", "position", "regex", "round", "selected", "selected-at", "string", "string-length", "substr", "sum", "today", "true"]
    },
    "spacing": {
      matchers: [["\n", "NEWLINE"]]
    },
    "unkown": {
      "abbr": "unk",
      matchers: ["undefined"]
    },
    "comparators": {
      abbr: "comp",
      matchers: [[">=", "GTE"], ["<=", "LTE"], ["!=", "NEQ"], ["=", "EQ"], [">", "GT"], ["<", "LT"]]
    },
    "operators": {
      abbr: "op",
      matchers: [["+", 'PLUS'], ["-", 'MINUS'], ["*", "MULT"], "div", "mod"]
    },
    "values": {
      "abbr": "val",
      matchers: [['""', 'EMPTY'], ["''", 'EMPTY'], ['NULL', 'NIL']]
    },
    "parentheses": {
      "abbr": "parens",
      matchers: [['(', 'OPEN'], [')', 'CLOSED']]
    },
    "logic": {
      abbr: "log",
      matchers: ["and", "or"]
    }
  };

  operators_by_code = {};

  Operator = (function() {
    Operator.lookup = {};

    function Operator(category_id, category_abbr, matcher) {
      var _ref;
      this.category_id = category_id;
      this.category_abbr = category_abbr;
      if (matcher === void 0) {
        throw new Error('cannot match undefined operator value');
      }
      if (_.isString(matcher)) {
        this.string = matcher;
      } else if (_.isArray(matcher)) {
        this.string = matcher[0], this.repr = matcher[1];
      } else {
        this.string = matcher.string;
        this.repr = matcher.repr;
        if (matcher.regex) {
          this.regex = new RegExp(matcher.regex);
        }
      }
      if (!this.repr) {
        this.repr = this.string.toUpperCase().replace(/-/g, '');
      }
      this.code = "" + this.category_abbr + "." + this.repr;
      if (this.category_id === 'punctuation' && ((_ref = this.string) === "." || _ref === "..")) {
        this.code = this.repr;
      }
      operators_by_code[this.code] = this;
    }

    return Operator;

  })();

  Operator.lookup = operators_by_code;

  operators = [];

  _ref = params.categories;
  for (_i = 0, _len = _ref.length; _i < _len; _i++) {
    category_id = _ref[_i];
    category = params[category_id];
    abbr = category.abbr || category_id;
    _ref1 = category.matchers;
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      matcher = _ref1[_j];
      operators.push(new Operator(category_id, abbr, matcher));
    }
  }

  operators.kls = Operator;

  operators.operator_list = operators;

  operators.operators_by_code = operators_by_code;


  /*
  Begin parse_expression
   */

  _contains = function(str, it) {
    return str.indexOf(it) !== -1;
  };

  _strStrip = function(str) {
    return str.replace(/^\s+|\s+$/g, "");
  };

  _replace_dict_items = function(_str, dict, wrap) {
    var key, val;
    if (wrap == null) {
      wrap = false;
    }
    for (key in dict) {
      val = dict[key];
      if (wrap) {
        _str = _str.replace(key, "" + wrap + val + wrap);
      } else {
        _str = _str.replace(key, val);
      }
    }
    return _str;
  };

  LOOKUP_REGEX = /^lookup\#(.*)$/;

  PATH_REGEX = /^path\#(.*)$/;

  STRIP_COMMAS = false;

  ESCAPED_CHARACTERS = {
    __ESC_DBL_QT__: '\\"',
    __ESC_SNG_QT__: "\\'"
  };

  operator_list = operators;

  Expression = (function() {
    function Expression(params) {
      if (params == null) {
        params = {};
      }
      this.uniqueIdCnt = 0;
      if (params.str) {
        this.parse_str(params.str);
      }
      if (params.arr) {
        this.parse_arr(params.arr);
      }
    }

    Expression.prototype.object_to_str = function(arr, join_with) {
      var arr2s;
      arr2s = function(arr, join_with) {
        var item, out, _k, _len2;
        if (join_with == null) {
          join_with = ' ';
        }
        out = [];
        for (_k = 0, _len2 = arr.length; _k < _len2; _k++) {
          item = arr[_k];
          if (_.isString(item) && operators_by_code[item]) {
            out.push(operators_by_code[item].string);
          } else if (_.isString(item)) {
            out.push(item);
          } else if (item.method) {
            out.push("" + item.method + "(" + (arr2s(item["arguments"], join_with)) + ")");
          } else if (item.lookup) {
            out.push("${" + item.lookup + "}");
          } else if (item.path) {
            out.push(arr2s(item.path, ''));
          } else if (_.isArray(item)) {
            out.push("(" + (arr2s(item)) + ")");
          }
        }
        return out.join(join_with);
      };
      return arr2s(arr, join_with);
    };

    Expression.prototype.parse_arr = function(arr) {
      var _asString;
      _asString = this.object_to_str(arr);
      this.toString = function() {
        return _asString;
      };
      return this.toObject = function() {
        return arr;
      };
    };

    Expression.prototype.parse_str = function(str) {
      var chunk, _as_json, _str, _unnested_object;
      this.original = str;
      _str = "" + this.original;
      this.local_replacements = [];
      this.dict = {};
      this.lookups = {};
      this.operators = {};
      this.paths = {};
      _str = this.replace_consts(_str);
      _str = this.pull_out_wrapped_quotes(_str, false);
      _str = this.pull_out_wrapped_quotes(_str, true);
      _str = this.convert_lookups(_str);
      this.anonymized = "" + _str;
      _str = this.pull_out_xpaths(_str);
      _str = this.pull_out_operators(_str);
      _str = this.strip_whitespace(_str);
      _str = _replace_dict_items(_str, this.operators, false);
      _str = _replace_dict_items(_str, this.paths, false);
      _str = _replace_dict_items(_str, this.lookups, false);
      this.chunked = (function() {
        var _k, _len2, _ref2, _results;
        _ref2 = _strStrip(_str).split(' ');
        _results = [];
        for (_k = 0, _len2 = _ref2.length; _k < _len2; _k++) {
          chunk = _ref2[_k];
          chunk = _replace_dict_items(chunk, this.dict, "'");
          _results.push(chunk);
        }
        return _results;
      }).call(this);
      this.items = this.chunked.map((function(_this) {
        return function(item) {
          return new ParsedChunk(item, {
            parentLine: _this
          });
        };
      })(this));
      _as_json = JSON.stringify(_.pluck(this.items, 'as_json'));
      _unnested_object = this._hacky_restructure_json(_as_json);
      this.as_structured_json = this.move_method_arguments(_unnested_object);
      this.toObject = (function(_this) {
        return function() {
          return _this.as_structured_json;
        };
      })(this);
      return this.toString = (function(_this) {
        return function() {
          return _this.as_structured_json;
        };
      })(this);
    };

    Expression.prototype._uniqueId = function(suffix) {
      return "" + suffix + (this.uniqueIdCnt++);
    };

    Expression.prototype.replace_consts = function(_str) {
      var key, val;
      for (key in ESCAPED_CHARACTERS) {
        val = ESCAPED_CHARACTERS[key];
        _str = _str.replace(val, key);
      }
      return _str;
    };

    Expression.prototype.pull_out_wrapped_quotes = function(_str, single) {
      var mtch, quote_char, _key, _val;
      if (single == null) {
        single = false;
      }
      quote_char = single ? "'" : '"';
      matcher = RegExp("(" + quote_char + "(.*?)" + quote_char + ")");
      mtch = _str.match(matcher);
      if (mtch && mtch.length > 0) {
        _key = this._uniqueId('REPLACESTR');
        _val = mtch[2];
        this.local_replacements.push(_key);
        this.dict[_key] = _replace_dict_items(_val, ESCAPED_CHARACTERS);
        _str = _str.replace(mtch[1], _key);
        _str = this.pull_out_wrapped_quotes(_str, single);
      }
      return _str;
    };

    Expression.prototype.pull_out_xpaths = function(_str) {
      var mtch, path_repl, path_str;
      while (mtch = _str.match(/(current\(\)|instance\([^\)]+\)|\.|\.\.)?(\/(\.\.|\w+|\*))+/)) {
        path_repl = this._uniqueId('PATH');
        path_str = mtch[0];
        _str = _str.replace(path_str, path_repl);
        this.paths[path_repl] = "path#" + path_str;
      }
      return _str;
    };

    Expression.prototype.convert_lookups = function(_str) {
      var insertion, mtch, _key, _val;
      mtch = _str.match(/^(.*?)\$\{(.+?)\}(.*)$/);
      if (mtch && mtch.length > 0) {
        _key = this._uniqueId('LOOKUPMTCHR');
        _val = "lookup#" + mtch[2];
        this.lookups[_key] = _val;
        insertion = _key;
        _str = "" + mtch[1] + insertion + mtch[3];
        _str = this.convert_lookups(_str);
      }
      return _str;
    };

    Expression.prototype.pull_out_operators = function(_str) {
      var loop_count, operator, uniquestr, _k, _len2;
      for (_k = 0, _len2 = operator_list.length; _k < _len2; _k++) {
        operator = operator_list[_k];
        if (operator.regex) {
          _str = _str.replace(operator.regex, " " + operator.code + " ");
          continue;
        }
        loop_count = 0;
        uniquestr = false;
        while (_contains(_str, operator.string)) {
          if (!uniquestr) {
            uniquestr = this._uniqueId('OPERATOR');
            this.operators[uniquestr] = operator.code;
          }
          loop_count++;
          _str = _str.replace(operator.string, " " + operator.code + " ");
          if (loop_count > 500) {
            throw new Error("infinite while loop");
          }
        }
      }
      return _str;
    };

    Expression.prototype.strip_whitespace = function(_str) {
      _str = _strStrip(_str);
      while (_contains(_str, '  ')) {
        _str = _str.replace('  ', ' ');
      }
      return _str;
    };

    Expression.prototype._hacky_restructure_json = function(json_str) {

      /*
      this converts the flat array to a JSON string, replaces the
      occurrences of "parens.OPEN" and "parens.CLOSED" with [ and ]
      and then converts it back to an array
       */
      var e, newstr;
      try {
        newstr = json_str.replace(/"parens\.OPEN"/g, '[').replace(/"parens\.CLOSED"/g, ']').replace(/\[,/g, '[').replace(/,\]/g, ']');
        if (STRIP_COMMAS) {
          newstr = newstr.replace(/"punc\.COMMA",/g, '');
        }
        return JSON.parse(newstr);
      } catch (_error) {
        e = _error;
        throw new Error('unmatched parentheses');
      }
    };

    Expression.prototype.move_method_arguments = function(arr) {
      var move_args;
      move_args = function(arr) {
        var n, out, push_arg;
        if (!_.isArray(arr) || (arr.length === 0)) {
          return arr;
        }
        out = [];
        n = 0;
        push_arg = function() {
          var item, next_item;
          item = arr[n];
          next_item = arr[n + 1];
          if (_.isString(item) && item.match(/^method\.(.*)$/) && _.isArray(next_item)) {
            out.push({
              method: operators_by_code[item].string,
              "arguments": move_args(next_item)
            });
            next_item = false;
            return n++;
          } else if (_.isArray(item)) {
            return out.push(move_args(item));
          } else {
            return out.push(item);
          }
        };
        while (n < arr.length) {
          push_arg(n);
          n++;
        }
        return out;
      };
      return move_args(arr);
    };

    return Expression;

  })();

  parse_expression.Kls = Expression;

  ParsedChunk = (function() {
    function ParsedChunk(_item, _arg) {
      var chunk_dotcode, matched, _mtch;
      this.parentLine = _arg.parentLine;
      this.as_json = _item;
      this.atts = [];
      if (_item.match(LOOKUP_REGEX)) {
        _mtch = _item.match(LOOKUP_REGEX);
        this._lookup_key = _mtch[1];
        this._value = "lookup#" + this._lookup_key;
        this.as_json = {
          lookup: this._lookup_key
        };
        this.dotcode = "xpath.LOOKUP";
        this.csscode = this.dotcode.toLowerCase().replace('.', '-');
        this.type = 'lookup';
      } else if (_item.match(PATH_REGEX)) {
        _mtch = _item.match(PATH_REGEX);
        this._path = _mtch[1];
        this.dotcode = "xpath.PATH";
        this.csscode = this.dotcode.toLowerCase().replace('.', '-');
        if (this._path.match(/^current\(\)/)) {
          this.as_json = {
            path: [
              {
                method: 'current',
                "arguments": []
              }, this._path.replace(/^current\(\)/, '')
            ]
          };
        } else if (this._path.match(/^instance\([^\)]+\)/)) {
          matched = this._path.match(/^instance\(([^\)]+)\)(.*)$/);
          this.as_json = {
            path: [
              {
                method: 'instance',
                "arguments": [matched[1]]
              }, matched[2]
            ]
          };
        } else {
          this.as_json = {
            path: this._path
          };
        }
      } else if (operators_by_code[_item]) {
        chunk_dotcode = _item;
        this._value = operators_by_code[_item].string;
        this.dotcode = chunk_dotcode;
        this.csscode = _item.toLowerCase().replace('.', '-');
        this.type = this.csscode.split('-')[0];
      } else {
        this._value = _item;
        this.type = 'unk';
      }
    }

    return ParsedChunk;

  })();

}).call(this);
